<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>G-BOY Tetris — Final (Single File)</title>

<!-- Firebase compat (Firestore) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<style>
:root{
  --frame-w:466px; --frame-h:729px; --canvas-w:333px; --canvas-h:337px;
  --panel-w:180px; --panel-gap:18px;
  --mob-btn-size:52px; --dpad-size:140px;
  --accent:#f6ae06;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:#0b0b0b;display:flex;align-items:center;justify-content:center;font-family:"Press Start 2P","VT323",monospace,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";color:#eaeaea}
.frame{position:relative;width:var(--frame-w);height:var(--frame-h);user-select:none}
.frame img{width:100%;height:100%;display:block;pointer-events:none;object-fit:cover}

/* canvas */
#tetrisCanvas{ position:absolute; width:var(--canvas-w); height:var(--canvas-h); left:51%; top:41%; transform:translate(-50%,-50%); z-index:2; image-rendering:pixelated; background:#000; border-radius:12px; box-shadow: 0 6px 20px rgba(0,0,0,0.6) inset; overflow:hidden; touch-action:none }

/* start overlay (canvas-sized) */
#startOverlay{ position:absolute; width:var(--canvas-w); height:var(--canvas-h); left:51%; top:41%; transform:translate(-50%,-50%); z-index:30; display:flex; align-items:center; justify-content:center; pointer-events:auto; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
.gb-screen{ width:100%; height:100%; background:linear-gradient(180deg, rgba(155,188,15,0.92), rgba(81,107,16,0.95)); border-radius:10px; padding:8px; display:flex; align-items:center; justify-content:center; position:relative }
.start-card{ width:calc(100% - 22px); height:calc(100% - 22px); display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; color:#072006; text-align:center; pointer-events:auto }
.gb-title{ font-size:12px; color:#072006; letter-spacing:2px; font-weight:700 }
.gb-sub{ font-size:10px; color:#0b2b08 }

/* start controls */
.gb-buttons{ display:flex; gap:8px; margin-top:8px }
.gb-btn{ padding:8px 10px; min-width:70px; border-radius:6px; border:2px solid rgba(3,40,2,0.35); background:linear-gradient(180deg, rgba(255,255,255,0.09), rgba(255,255,255,0.03)); color:#062806; font-weight:800; cursor:pointer }
.gb-btn.active{ background:linear-gradient(180deg, rgba(48,102,12,0.95), rgba(25,60,8,0.9)); color:#dff3b8 }

/* start action */
.start-action{ margin-top:10px; padding:8px 12px; border-radius:8px; background:#072006; color:#bff0a0; font-weight:900; border:2px solid rgba(255,255,255,0.06); cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,0.5) }

/* game-over overlay */
#gameOverOverlay{ position:absolute; width:var(--canvas-w); height:var(--canvas-h); left:51%; top:41%; transform:translate(-50%,-50%); z-index:40; display:none; border-radius:12px; background:rgba(0,0,0,0.92); padding:10px; box-sizing:border-box; color:#fff }
.go-inner{ width:75%; margin:0 auto; display:flex; flex-direction:column; gap:8px; align-items:center }
.go-stats{ width:100%; text-align:center; font-weight:700; padding:8px; border-radius:6px; background:rgba(255,255,255,0.02) }
/* removed inner "restart" under name per request */

/* side panel */
.sidePanel{ position:absolute; left: calc(60% + (var(--canvas-w) / 2) + var(--panel-gap)); top:50%; transform:translateY(-50%); width:var(--panel-w); z-index:3; display:flex; flex-direction:column; gap:12px; pointer-events:auto }
.panelCard{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:0px; border-radius:12px; color:#f3f3f3; box-shadow:0 8px 20px rgba(0,0,0,0.6); font-size:13px; border:1px solid rgba(255,255,255,0.04) }
.panelTitle{ font-weight:700; font-size:16px; margin-bottom:8px; color:var(--accent) }
.preview{ background:rgba(11,11,11,0.45); border-radius:8px; padding:8px; display:flex; align-items:center; justify-content:center; min-height:72px }

/* music controls */
.music-controls{ display:flex; gap:8px; align-items:center; margin-top:8px }
.music-btn{ padding:6px 8px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.06); color:#fff; cursor:pointer; font-weight:700 }
.music-slider{ width:90px }

/* leaderboard modal */
.lb-modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px) }
.lb-card{ width:min(680px,94%); background:linear-gradient(180deg,#0c0c0c,#0b0b0b); border-radius:12px; padding:18px; box-shadow:0 12px 40px rgba(0,0,0,0.7); color:#fff; border:1px solid rgba(255,255,255,0.04); }
.lb-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px }
.lb-title{ font-weight:800; font-size:16px; color:#ffd966 }
.lb-close{ background:#222; padding:6px 10px; border-radius:8px; color:#fff; cursor:pointer; border:1px solid rgba(255,255,255,0.06) }
.lb-table{ width:100%; border-collapse:collapse; font-weight:700 }
.lb-table th, .lb-table td{ padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03); font-size:13px }
.lb-table th{ color:#f6ae06; text-transform:uppercase; font-size:12px }

/* name input in gameover */
.name-input{ display:flex; gap:8px; width:100%; margin-top:8px }
.name-input input{ flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:rgba(255,255,255,0.02); color:#fff }

/* HINTS — now a panelCard style (moved from floating to bottom of sidePanel) */
.hintCard{ display:flex; flex-direction:column; gap:6px; align-items:flex-start; font-size:12px; color:var(--accent) }
.hintCard .hintTitle{ font-weight:800; color:#ffd966; font-size:12px; margin-bottom:4px }
.hintBox{ background:rgba(0,0,0,0.35); padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:#dfe8c8; width:100%; box-sizing:border-box }

/* touch controls (floating under device) */
.touch-controls{ position:absolute; left:50%; transform:translateX(-50%); top:calc(41% + var(--canvas-h) + 10px); z-index:30; display:flex; gap:10px; justify-content:center; pointer-events:auto }
.touch-pad{ display:flex; gap:8px; align-items:center; justify-content:center }

/* small mobile buttons (we also include #mobile-controls compatibility) */
.tc-btn{ width:44px; height:44px; border-radius:8px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); color:#fff; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:16px; touch-action:manipulation; cursor:pointer }
.tc-wide{ width:80px }

/* Mobile only visibility */
@media (min-width:1200px){ .touch-controls{ display:none } }
@media (max-width:1199px){ .sidePanel{ display:none } } /* hide side on Tablet & below for space */

@media (max-width:900px){
  .frame{ transform:scale(0.9) }
}

/* mobile D-pad precise overlay */
#mobile-controls{ display:none }
@media (max-width:768px){
  #mobile-controls{ display:block; position:absolute; z-index:50; left:50%; transform:translateX(-50%); top:calc(41% + var(--canvas-h) + 10px); width:calc(var(--frame-w) - 40px); pointer-events:none }
  #dpad{ position:relative; width:var(--dpad-size); height:var(--dpad-size); left:12px; pointer-events:none }
  .mob-btn{ position:absolute; width:var(--mob-btn-size); height:var(--mob-btn-size); border-radius:50%; background:rgba(255,255,255,0.12); border:1px solid rgba(255,255,255,0.25); backdrop-filter:blur(6px); color:#fff; display:flex; align-items:center; justify-content:center; pointer-events:auto }
  #dpad .rotate{ left: calc((var(--dpad-size) - var(--mob-btn-size))/2); top: 0 }
  #dpad .left{ left:0; top: calc((var(--dpad-size) - var(--mob-btn-size))/2) }
  #dpad .down{ left: calc((var(--dpad-size) - var(--mob-btn-size))/2); top: calc((var(--dpad-size) - var(--mob-btn-size))/2) }
  #dpad .right{ left: calc(var(--dpad-size) - var(--mob-btn-size)); top: calc((var(--dpad-size) - var(--mob-btn-size))/2) }
  #mobile-actions{ position:absolute; left: calc(var(--dpad-size) + 36px); top: 18px; display:flex; flex-direction:column; gap:8px; pointer-events:none }
  #mobile-actions .mob-btn{ pointer-events:auto; width:54px; height:54px; border-radius:10px; font-size:13px }
}

/* small helper */
.btn{ padding:8px 10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.06); color:#fff; cursor:pointer; font-weight:600 }
</style>
</head>
<body>
  <div class="frame" id="frame">
    <img id="bg" src="tetris.png" alt="G-BOY">
    <canvas id="tetrisCanvas" aria-label="Tetris alanı"></canvas>

    <!-- START OVERLAY -->
    <div id="startOverlay" aria-hidden="false">
      <div class="gb-screen" role="dialog" aria-label="Start Menu - GameBoy">
        <div class="start-card" id="startCard">
          <h3 class="gb-title">G - B O Y</h3>
          <div class="gb-sub">T E T R I S</div>

          <div class="gb-buttons" role="radiogroup" aria-label="Difficulty">
            <button class="gb-btn" id="gbEasy" data-diff="EASY">EASY</button>
            <button class="gb-btn active" id="gbNormal" data-diff="NORMAL">NORMAL</button>
            <button class="gb-btn" id="gbHard" data-diff="HARD">HARD</button>
          </div>

          <button class="start-action" id="gbStart">PRESS START</button>
          <div class="gb-hint">← → to change • Enter to start • Mouse clickable</div>
        </div>
      </div>
    </div>

    <!-- GAME OVER overlay (note: removed inner restart under name as requested) -->
    <div id="gameOverOverlay" aria-hidden="true">
      <div class="go-inner" role="dialog" aria-modal="true">
        <img src="game-over.png" alt="Game Over" class="go-image" style="max-width:70%;opacity:0.95" />
        <div class="go-stats" aria-live="polite">
          <div class="row">Score: <span id="goScore">0</span></div>
          <div class="row">Level: <span id="goLevel">0</span></div>
          <div class="row">Lines: <span id="goLines">0</span></div>
          <div class="row go-best">Best: <span id="bestScore">0</span></div>

          <div id="submitNameArea" style="margin-top:8px; display:none;">
            <div style="font-size:12px;margin-bottom:6px;color:#dfe8c8">Enter name to save your score:</div>
            <div class="name-input">
              <input type="text" id="playerNameInput" placeholder="Your name (max 20 chars)" maxlength="20" />
              <button id="submitScoreBtn" class="btn">SUBMIT</button>
            </div>
            <div style="font-size:11px;margin-top:6px;color:#cfcfcf">Saved scores appear on the Leaderboard.</div>
          </div>

          <!-- removed redundant restart here -->
        </div>
      </div>
    </div>

    <!-- Side panel -->
    <div class="sidePanel" aria-hidden="false">
      <div class="panelCard">
        <div class="panelTitle">NEXT</div>
        <div class="preview"><canvas id="nextCanvas" class="previewCanvas" width="128" height="128"></canvas></div>
      </div>

      <div class="panelCard">
        <div class="panelTitle">HOLD</div>
        <div class="preview"><canvas id="holdCanvas" class="previewCanvas" width="128" height="128"></canvas></div>
      </div>

      <div class="panelCard">
        <div class="panelTitle">SCORE</div>
        <div class="hudSmall">Point: <span id="score">0</span></div>
        <div class="hudSmall" style="margin-top:8px">Level: <span id="level">1</span> · Lines: <span id="lines">0</span></div>
      </div>

      <div class="panelCard">
        <div style="display:flex;flex-direction:column;gap:8px">
          <div style="display:flex;gap:8px">
            <button id="pauseBtn" class="btn">Pause</button>
            <button id="restartBtn" class="btn">Restart</button>
          </div>

          <div class="music-controls" id="musicControls">
            <button id="musicToggle" class="music-btn">Music: ON</button>
            <input id="musicVolume" class="music-slider" type="range" min="0" max="1" step="0.01" value="0.35" title="Volume">
          </div>

          <div style="margin-top:6px; display:flex; gap:8px; align-items:center;">
            <button id="leaderboardBtn" class="btn">Leaderboard</button>
          </div>
        </div>
      </div>

      <!-- Hints moved into sidePanel as a card -->
      <div class="panelCard hintCard" aria-hidden="false">
        <div class="hintTitle">HINTS</div>
        <div class="hintBox">
          Controls: ← → ↓ ↑ • Space = Hard Drop • Shift = Hold • P = Pause
          <br/><small style="color:#cfcfcf">Touch: ◀ ▶ 🔄 ▼ • Drop • H</small>
        </div>
      </div>
    </div>

    <!-- Mobile special overlay (D-Pad and actions) -->
    <div id="mobile-controls">
      <div id="dpad">
        <button class="mob-btn rotate" id="mob-rotate">🔄</button>
        <button class="mob-btn left" id="mob-left">◀</button>
        <button class="mob-btn down" id="mob-down">▼</button>
        <button class="mob-btn right" id="mob-right">▶</button>
      </div>
      <div id="mobile-actions">
        <button class="mob-btn" id="mob-hold">⭕</button>
        <button class="mob-btn" id="mob-drop">⬛</button>
      </div>
    </div>

    <!-- floating touch-controls (alternative) -->
    <div class="touch-controls" id="touchControls" aria-hidden="false" style="display:none">
      <div class="touch-pad">
        <div class="tc-btn" id="tc-left">◀</div>
        <div class="tc-btn" id="tc-right">▶</div>
        <div class="tc-btn" id="tc-rotate">🔄</div>
        <div class="tc-btn" id="tc-down">▼</div>
        <div class="tc-btn tc-wide" id="tc-drop">Drop</div>
        <div class="tc-btn" id="tc-hold">H</div>
      </div>
    </div>

  </div>

  <!-- Leaderboard modal -->
  <div class="lb-modal" id="leaderboardModal" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="lb-card" role="document">
      <div class="lb-header">
        <div class="lb-title">🏆 GLOBAL LEADERBOARD</div>
        <div style="display:flex;gap:8px">
          <button id="lbRefresh" class="lb-close">Refresh</button>
          <button id="lbClose" class="lb-close">X</button>
        </div>
      </div>

      <div id="leaderboardContent">
        <table class="lb-table" id="leaderboardTable">
          <thead><tr><th style="width:64px">Rank</th><th>Name</th><th>Score</th></tr></thead>
          <tbody id="leaderboardTbody"><tr><td colspan="3">Loading…</td></tr></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/* =========================
   CONFIG, DOM, HI-DPI SET
   ========================= */
const CANVAS_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--canvas-w')) || 333;
const CANVAS_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--canvas-h')) || 337;
const COLS = 22, ROWS = 21;
const DIFFICULTY_SPEEDS = { EASY:450, NORMAL:300, HARD:160 };
let selectedDifficulty = 'NORMAL';
let dropSpeedBase = DIFFICULTY_SPEEDS[selectedDifficulty];

const canvas = document.getElementById('tetrisCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas && nextCanvas.getContext ? nextCanvas.getContext('2d') : null;
const holdCanvas = document.getElementById('holdCanvas');
const holdCtx = holdCanvas && holdCanvas.getContext ? holdCanvas.getContext('2d') : null;

const startOverlay = document.getElementById('startOverlay');
const gbEasy = document.getElementById('gbEasy');
const gbNormal = document.getElementById('gbNormal');
const gbHard = document.getElementById('gbHard');
const gbStart = document.getElementById('gbStart');

const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');

const overlay = document.getElementById('gameOverOverlay');
const goScore = document.getElementById('goScore');
const goLevel = document.getElementById('goLevel');
const goLines = document.getElementById('goLines');
const bestScoreEl = document.getElementById('bestScore');

const submitNameArea = document.getElementById('submitNameArea');
const playerNameInput = document.getElementById('playerNameInput');
const submitScoreBtn = document.getElementById('submitScoreBtn');

const musicToggle = document.getElementById('musicToggle');
const musicVolume = document.getElementById('musicVolume');

const leaderboardBtn = document.getElementById('leaderboardBtn');
const leaderboardModal = document.getElementById('leaderboardModal');
const lbClose = document.getElementById('lbClose');
const lbRefresh = document.getElementById('lbRefresh');
const leaderboardTbody = document.getElementById('leaderboardTbody');

const mobLeft = document.getElementById('mob-left');
const mobRight = document.getElementById('mob-right');
const mobDown = document.getElementById('mob-down');
const mobRotate = document.getElementById('mob-rotate');
const mobDrop = document.getElementById('mob-drop');
const mobHold = document.getElementById('mob-hold');

const dpr = window.devicePixelRatio || 1;
canvas.width = CANVAS_W * dpr; canvas.height = CANVAS_H * dpr;
canvas.style.width = CANVAS_W + 'px'; canvas.style.height = CANVAS_H + 'px';
ctx.setTransform(dpr,0,0,dpr,0,0);
ctx.imageSmoothingEnabled = false;

/* Preview canvases safe prepare */
function preparePreviewCanvas(c){ if(!c) return; const cp = c.getContext('2d'); cp.clearRect(0,0,c.width,c.height); cp.imageSmoothingEnabled = false; }
preparePreviewCanvas(nextCanvas); preparePreviewCanvas(holdCanvas);

/* =========================
   SHAPES & HELPERS
   ========================= */
const COLORS = {0:'rgba(0,0,0,0)', I:'#00f0f0', J:'#0000f0', L:'#f0a000', O:'#f0f000', S:'#00f000', T:'#a000f0', Z:'#f00000', Q:'random'};
const RANDOM_COLORS = ['#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff'];
function getRandomColor(){ return RANDOM_COLORS[(Math.random()*RANDOM_COLORS.length)|0]; }
const SHAPES = {
  I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J:[[1,0,0],[1,1,1],[0,0,0]],
  L:[[0,0,1],[1,1,1],[0,0,0]],
  O:[[1,1],[1,1]],
  S:[[0,1,1],[1,1,0],[0,0,0]],
  T:[[0,1,0],[1,1,1],[0,0,0]],
  Z:[[1,1,0],[0,1,1],[0,0,0]],
  Q:[[1]]
};
const PIECES = 'IJLOSTZQ';
function createMatrix(w,h){ const m=[]; for(let y=0;y<h;y++) m.push(new Array(w).fill(0)); return m; }
function createPiece(type){ const s=SHAPES[type]; return s.map(r=>r.map(v=>v?type:0)); }
function drawCellAt(context,x,y,size,color){ const pad=Math.max(1,Math.floor(size*0.06)); context.fillStyle=(color==='random')?getRandomColor():color; context.fillRect(x+pad,y+pad,size-2*pad,size-2*pad); context.strokeStyle='rgba(255,255,255,0.05)'; context.strokeRect(x+pad,y+pad,size-2*pad,size-2*pad); }

/* =========================
   GAME STATE
   ========================= */
const COLS_USED = COLS, ROWS_USED = ROWS;
const arena = createMatrix(COLS_USED, ROWS_USED);
let score=0, level=1, lines=0;
let dropCounter=0, lastTime=0;
let isPaused=false, isGameOver=false, isRunning=false;
let gameStarted=false, allowGameOver=false;
const player = { pos:{x:0,y:0}, matrix:null, type:0 };
let holdPiece = null, canHold=true;
const queue = [];

/* cell sizing based on canvas */
const cellSize = Math.floor(Math.min(CANVAS_W / COLS_USED, CANVAS_H / ROWS_USED));
let offsetX = Math.floor((CANVAS_W - (cellSize*COLS_USED)) / 2);
let offsetY = Math.floor((CANVAS_H - (cellSize*ROWS_USED)) / 2);

/* =========================
   AUDIO (BGM + SFX) — left unchanged as requested
   ========================= */
let audioCtx=null, bgMusic=null;
let musicEnabled = true;
let musicVolumeVal = parseFloat(musicVolume && musicVolume.value ? musicVolume.value : 0.35);
function ensureAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx=null } }
function unlockAudio(){ if(!audioCtx) return; if(audioCtx.state==='suspended' && audioCtx.resume) audioCtx.resume(); }
function playBeep(freq=440,time=0.08,type='sine',gain=0.12){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(audioCtx.destination); const now=audioCtx.currentTime; o.start(now); g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.001, now+time); o.stop(now+time+0.02); }
function playLineClear(){ playBeep(880,0.12,'square',0.14); setTimeout(()=>playBeep(660,0.08,'sine',0.08),80); }
function playRotate(){ if(audioCtx) playBeep(1000,0.06,'sine',0.07); }
function playDrop(){ if(audioCtx) playBeep(300,0.02,'sine',0.06); }
function playGameOver(){ if(audioCtx) playBeep(180,0.4,'sawtooth',0.18); }

function startBGM(){
  if(!musicEnabled) return;
  try{
    stopBGM();
    bgMusic = new Audio('tetris_bgm.m4a'); // put m4a at project root or change path
    bgMusic.loop = true; bgMusic.volume = musicVolumeVal;
    bgMusic.play().catch(e=>console.warn('bgMusic play failed', e));
  }catch(e){
    console.warn('startBGM err', e);
  }
}
function stopBGM(){
  try{ if(bgMusic){ bgMusic.pause(); try{ bgMusic.currentTime = 0 }catch(e){} bgMusic=null } }catch(e){}
}

/* =========================
   BAG / QUEUE
   ========================= */
function nextBag(){ const bag = PIECES.split(''); for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; } return bag; }
function ensureQueue(){ while(queue.length<14) queue.push(...nextBag()); }

/* SPAWN */
function playerReset(){
  ensureQueue();
  const t = queue.shift();
  player.type = t;
  player.matrix = createPiece(t);
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS_USED - player.matrix[0].length)/2);
  canHold = true;
  if(collide(arena, player)){
    if(allowGameOver) showGameOverScreen();
    else for(let y=0;y<ROWS_USED;y++) arena[y].fill(0);
    return;
  }
  renderPreviews();
}

/* COLLIDE */
function collide(arena, pl){
  const m = pl.matrix, o = pl.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(!m[y][x]) continue;
      const ay = y+o.y, ax = x+o.x;
      if(ay<0 || ay>=ROWS_USED || ax<0 || ax>=COLS_USED) return true;
      if(arena[ay][ax]) return true;
    }
  }
  return false;
}
function merge(arena, pl){ pl.matrix.forEach((row,y)=>row.forEach((val,x)=>{ if(val) arena[y+pl.pos.y][x+pl.pos.x] = pl.type })); }

/* SWEEP */
function sweep(){
  let rowCount=0;
  outer: for(let y=ROWS_USED-1;y>=0;y--){
    for(let x=0;x<COLS_USED;x++){
      if(!arena[y][x]) continue outer;
    }
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    y++;
    rowCount++;
  }
  if(rowCount>0){
    lines += rowCount;
    score += Math.pow(2,rowCount-1) * 100 * level;
    level = Math.floor(lines / 10) + 1;
    updateUI();
    flash();
    playLineClear();
  }
}
function flash(){ ctx.save(); ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H); setTimeout(()=>{ ctx.restore(); draw(); },120); }

/* ROTATE with wallkick */
function rotate(m,dir){ for(let y=0;y<m.length;y++){ for(let x=0;x<y;x++){ [m[x][y],m[y][x]]=[m[y][x],m[x][y]] } } if(dir>0) m.forEach(row=>row.reverse()); else m.reverse(); }
function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(Math.abs(offset) > player.matrix[0].length){
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
  playRotate();
}

/* GHOST */
function computeGhost(){
  const ghost = { pos:{x:player.pos.x,y:player.pos.y}, matrix:player.matrix };
  while(!collide(arena, ghost)) ghost.pos.y++;
  ghost.pos.y--;
  return ghost;
}

/* DRAW */
function clearBoard(){ ctx.fillStyle='#000'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H); }
function drawPlaced(){ for(let y=0;y<ROWS_USED;y++) for(let x=0;x<COLS_USED;x++){ const v=arena[y][x]; if(v){ const drawX = offsetX + x*cellSize; const drawY = offsetY + y*cellSize; drawCellAt(ctx, drawX, drawY, cellSize, COLORS[v]); } } }
function drawPlayer(){ drawMatrix(player.matrix, player.pos, ctx); }
function drawMatrix(matrix, offset, cctx){ for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++) if(matrix[y][x]){ const drawX = offsetX + (offset.x + x)*cellSize; const drawY = offsetY + (offset.y + y)*cellSize; drawCellAt(cctx, drawX, drawY, cellSize, COLORS[matrix[y][x]]); } }
function drawGhost(){ const ghost = computeGhost(); if(!ghost) return; ctx.globalAlpha = 0.22; for(let y=0;y<ghost.matrix.length;y++) for(let x=0;x<ghost.matrix[y].length;x++) if(ghost.matrix[y][x]){ const gx=ghost.pos.x + x; const gy=ghost.pos.y + y; const drawX = offsetX + gx*cellSize; const drawY = offsetY + gy*cellSize; drawCellAt(ctx, drawX, drawY, cellSize, COLORS[ghost.matrix[y][x]]); } ctx.globalAlpha = 1; }
function draw(){ clearBoard(); drawPlaced(); drawGhost(); drawPlayer(); }

/* LOOP */
function update(time=0){
  if(!isRunning || isPaused || isGameOver){ requestAnimationFrame(update); return; }
  const delta = time - lastTime; lastTime = time; dropCounter += delta;
  const speed = Math.max(80, dropSpeedBase - (level-1)*80);
  if(dropCounter > speed) playerDrop();
  draw();
  requestAnimationFrame(update);
}

/* MOVES */
function playerDrop(){ player.pos.y++; if(collide(arena, player)){ player.pos.y--; merge(arena, player); sweep(); playerReset(); } dropCounter = 0; playDrop(); }
function playerHardDrop(){ while(!collide(arena, player)) player.pos.y++; player.pos.y--; merge(arena, player); sweep(); playerReset(); dropCounter = 0; playDrop(); }
function playerMove(dir){ player.pos.x += dir; if(collide(arena, player)) player.pos.x -= dir; }

/* HOLD */
function doHold(){
  if(!canHold || isGameOver) return;
  if(!holdPiece){ holdPiece = player.type; playerReset(); }
  else {
    const tmp = holdPiece;
    holdPiece = player.type;
    player.type = tmp;
    player.matrix = createPiece(player.type);
    player.pos.y = 0;
    player.pos.x = Math.floor((COLS_USED - player.matrix[0].length)/2);
    if(collide(arena, player)){ for(let y=0;y<ROWS_USED;y++) arena[y].fill(0); score=0; level=1; lines=0; updateUI(); }
  }
  canHold = false; renderPreviews();
}

/* UI & PREVIEWS */
function updateUI(){ scoreEl.textContent = score; levelEl.textContent = level; linesEl.textContent = lines; }
function renderPreviewTo(ctxP, pieceType){ if(!ctxP) return; const W=ctxP.canvas.width,H=ctxP.canvas.height; ctxP.clearRect(0,0,W,H); if(!pieceType) return; const m=createPiece(pieceType); const pSize=Math.floor(Math.min(W / m[0].length, H / m.length)); const startX=Math.floor((W - m[0].length*pSize)/2); const startY=Math.floor((H - m.length*pSize)/2); for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if(m[y][x]){ ctxP.fillStyle = (COLORS[pieceType]==='random')?getRandomColor():COLORS[pieceType]; ctxP.fillRect(startX + x*pSize + 2, startY + y*pSize + 2, pSize - 4, pSize - 4); } }
function renderPreviews(){ renderPreviewTo(nextCtx, queue[0] || null); renderPreviewTo(holdCtx, holdPiece); }

/* KEYS */
document.addEventListener('keydown', e=>{
  if(!gameStarted && startOverlay.style.display !== 'none'){
    if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') cycleDifficulty(e.key === 'ArrowRight' ? 1 : -1);
    else if(e.key === '1') setDifficulty('EASY');
    else if(e.key === '2') setDifficulty('NORMAL');
    else if(e.key === '3') setDifficulty('HARD');
    else if(e.key === 'Enter') gbStart.click();
    return;
  }
  if(!isRunning || isGameOver) return;
  if(e.key === 'ArrowLeft'){ playerMove(-1); dropCounter = 0; }
  else if(e.key === 'ArrowRight'){ playerMove(1); dropCounter = 0; }
  else if(e.key === 'ArrowDown'){ playerDrop(); }
  else if(e.key === ' '){ e.preventDefault(); playerHardDrop(); }
  else if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'x'){ playerRotate(1); }
  else if(e.key === 'p' || e.key === 'P' || e.key === 'Escape'){ togglePause(); }
  else if(e.key === 'Shift'){ doHold(); }
});

/* BUTTONS */
pauseBtn.addEventListener('click', ()=>{ togglePause(); });

/* Modified Restart behaviour:
   - Side "Restart" button now returns player to the START overlay (reset state)
   as requested ("Sağdaki Restart tuşuna basınca tekrar start ekranını görmem gerek").
*/
restartBtn.addEventListener('click', ()=>{
  // Stop any running game and show start overlay (reset state to initial)
  overlay.style.display='none'; overlay.setAttribute('aria-hidden','true');
  submitNameArea.style.display='none';
  isGameOver=false; isPaused=false; isRunning=false; gameStarted=false; allowGameOver=false;
  for(let y=0;y<ROWS_USED;y++) arena[y].fill(0);
  score=0; level=1; lines=0; updateUI();
  queue.length=0; queue.push(...nextBag()); ensureQueue(); playerReset();
  startOverlay.style.display='flex'; startOverlay.setAttribute('aria-hidden','false');
  pauseBtn.disabled = true; restartBtn.disabled = true;
  stopBGM();
});

/* goRestart was removed from UI; keep safe no-op if referenced */
try{ const __maybeGoRestart = document.getElementById('goRestart'); if(__maybeGoRestart) __maybeGoRestart.style.display='none'; }catch(e){}

/* TOUCH / MOBILE BINDINGS */
function bindTouch(el, handler){
  if(!el) return;
  const onStart = (ev)=>{ ev.preventDefault(); handler(); };
  el.addEventListener('touchstart', onStart, {passive:false});
  el.addEventListener('mousedown', onStart);
}
bindTouch(mobLeft, ()=>{ playerMove(-1); dropCounter = 0; });
bindTouch(mobRight, ()=>{ playerMove(1); dropCounter = 0; });
bindTouch(mobRotate, ()=>{ playerRotate(1); });
bindTouch(mobDown, ()=>{ playerDrop(); });
bindTouch(mobDrop, ()=>{ playerHardDrop(); });
bindTouch(mobHold, ()=>{ doHold(); });

/* PAUSE */
function togglePause(){ if(isGameOver) return; isPaused = !isPaused; pauseBtn.textContent = isPaused ? 'Resume' : 'Pause'; if(!isPaused){ lastTime = performance.now(); if(musicEnabled && bgMusic) try{ bgMusic.play(); }catch(e){} } else { if(bgMusic) try{ bgMusic.pause(); }catch(e){} } }

/* GAME OVER / BEST */
const BEST_KEY = 'gbox_tetris_best';
function readBest(){ const b = parseInt(localStorage.getItem(BEST_KEY) || '0',10); return isNaN(b)?0:b; }
function writeBest(v){ localStorage.setItem(BEST_KEY, String(v)); }

/* SHOW GAME OVER */
function showGameOverScreen(){
  if(!allowGameOver) return;
  isGameOver = true; isPaused = true;
  goScore.textContent = score; goLevel.textContent = level; goLines.textContent = lines;
  const best = Math.max(readBest(), score); writeBest(best); bestScoreEl.textContent = best;
  overlay.style.display = 'flex'; overlay.setAttribute('aria-hidden','false');
  submitNameArea.style.display = 'block';
  playerNameInput.value = '';
  playerNameInput.focus && playerNameInput.focus();
  stopBGM(); playGameOver();
  isRunning = false; gameStarted = false; allowGameOver = false;
  pauseBtn.disabled = true; restartBtn.disabled = false;
}

/* SUBMIT SCORE (Game Over modal) */
const submitScoreBtnEl = document.getElementById('submitScoreBtn');
submitScoreBtnEl && submitScoreBtnEl.addEventListener('click', async ()=>{
  const name = (playerNameInput.value || '').trim().slice(0,20) || ('Player'+Math.floor(Math.random()*900+100));
  submitScoreBtnEl.disabled = true; submitScoreBtnEl.textContent = 'Saving...';
  const ok = await submitScoreToFirestore(name, score);
  submitScoreBtnEl.textContent = ok ? 'Saved' : 'Error';
  setTimeout(()=>{
    submitScoreBtnEl.disabled = false; submitScoreBtnEl.textContent = 'SUBMIT';
    overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); submitNameArea.style.display='none';
    // reset + show start
    isGameOver=false; isPaused=false; isRunning=false; gameStarted=false; allowGameOver=false;
    for(let y=0;y<ROWS_USED;y++) arena[y].fill(0);
    score=0; level=1; lines=0; updateUI();
    queue.length=0; queue.push(...nextBag()); ensureQueue(); playerReset();
    startOverlay.style.display='flex'; startOverlay.setAttribute('aria-hidden','false');
    pauseBtn.disabled = true; restartBtn.disabled = true;
    stopBGM();
  },900);
});

/* RESTART GAME (used internally to actually restart playing immediately) */
function restartGame(){
  overlay.style.display='none'; overlay.setAttribute('aria-hidden','true');
  submitNameArea.style.display='none';
  isGameOver=false; isPaused=false;
  for(let y=0;y<ROWS_USED;y++) arena[y].fill(0);
  score=0; level=1; lines=0;
  queue.length=0; queue.push(...nextBag());
  playerReset(); updateUI();
  isRunning=true; gameStarted=true; allowGameOver=true;
  pauseBtn.disabled=false; restartBtn.disabled=false;
  if(musicEnabled) startBGM();
  lastTime = performance.now();
  requestAnimationFrame(update);
}

/* DIFFICULTY/START UI */
function setDifficulty(d){ selectedDifficulty=d; dropSpeedBase=DIFFICULTY_SPEEDS[selectedDifficulty]; [gbEasy,gbNormal,gbHard].forEach(b=>b.classList.remove('active')); if(d==='EASY') gbEasy.classList.add('active'); if(d==='NORMAL') gbNormal.classList.add('active'); if(d==='HARD') gbHard.classList.add('active'); }
function cycleDifficulty(dir){ const order=['EASY','NORMAL','HARD']; let idx=order.indexOf(selectedDifficulty); idx=(idx+dir+order.length)%order.length; setDifficulty(order[idx]); }
gbEasy.addEventListener('click', ()=>setDifficulty('EASY'));
gbNormal.addEventListener('click', ()=>setDifficulty('NORMAL'));
gbHard.addEventListener('click', ()=>setDifficulty('HARD'));

/* START button behavior */
gbStart.addEventListener('click', ()=>{
  ensureAudio(); unlockAudio(); playBeep(600,0.06,'square',0.08);
  dropSpeedBase = DIFFICULTY_SPEEDS[selectedDifficulty];
  isRunning=true; isPaused=false; isGameOver=false; gameStarted=true; allowGameOver=true;
  pauseBtn.disabled=false; restartBtn.disabled=false;
  if(musicEnabled) startBGM();
  queue.length=0; queue.push(...nextBag()); ensureQueue(); playerReset(); updateUI();
  startOverlay.style.display='none'; startOverlay.setAttribute('aria-hidden','true');
  lastTime = performance.now();
  requestAnimationFrame(update);
});

/* MUSIC UI (unchanged) */
function updateMusicUI(){ musicToggle.textContent = musicEnabled ? 'Music: ON' : 'Music: OFF'; }
musicToggle.addEventListener('click', ()=>{
  musicEnabled = !musicEnabled;
  if(musicEnabled) startBGM(); else stopBGM();
  updateMusicUI();
});
musicVolume.addEventListener('input', (e)=>{
  musicVolumeVal = parseFloat(e.target.value);
  if(bgMusic) try{ bgMusic.volume = musicVolumeVal }catch(e){}
});

/* LEADERBOARD (Firestore) */
const firebaseConfig = {
  apiKey: "AIzaSyCSx1tcY0f1_s6n_0sr0wVngw5ovJmae7k",
  authDomain: "tetrisleaderboard-733bd.firebaseapp.com",
  projectId: "tetrisleaderboard-733bd",
  storageBucket: "tetrisleaderboard-733bd.firebasestorage.app",
  messagingSenderId: "439520589387",
  appId: "1:439520589387:web:680ac7257a9e61a5e93fce",
  measurementId: "G-88031G3EL3"
};
try{
  firebase.initializeApp(firebaseConfig);
}catch(e){
  console.warn('Firebase init: maybe already initialized', e);
}
const db = firebase.firestore();

async function submitScoreToFirestore(name, scoreVal){
  if(!db) return false;
  try{
    await db.collection('scores').add({
      name: (name && name.trim().length) ? name.trim().slice(0,20) : 'Player',
      score: Number(scoreVal) || 0,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    return true;
  }catch(err){
    console.error('submitScore error', err);
    return false;
  }
}

async function loadTopScores(limitNum = 10){
  if(!db) return [];
  try{
    const q = db.collection('scores').orderBy('score','desc').limit(limitNum);
    const snap = await q.get();
    const arr = [];
    snap.forEach(doc=> arr.push(doc.data()));
    return arr;
  }catch(err){ console.error('loadTopScores error', err); return [] }
}

async function renderLeaderboard(){
  leaderboardTbody.innerHTML = '<tr><td colspan="3">Loading…</td></tr>';
  const rows = await loadTopScores(10);
  if(!rows || rows.length === 0){ leaderboardTbody.innerHTML = '<tr><td colspan="3">No scores yet</td></tr>'; return; }
  let html='';
  rows.forEach((r, idx)=>{
    const name = r.name || 'Player';
    const scoreNum = r.score || 0;
    html += `<tr><td style="width:64px">${idx+1}</td><td>${escapeHtml(name)}</td><td>${Number(scoreNum)}</td></tr>`;
  });
  leaderboardTbody.innerHTML = html;
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, (m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* leaderboard UI handlers */
leaderboardBtn.addEventListener('click', async ()=>{
  document.getElementById('leaderboardModal').style.display='flex';
  document.getElementById('leaderboardModal').setAttribute('aria-hidden','false');
  await renderLeaderboard();
});
lbClose.addEventListener('click', ()=>{ document.getElementById('leaderboardModal').style.display='none'; document.getElementById('leaderboardModal').setAttribute('aria-hidden','true'); });
lbRefresh.addEventListener('click', async ()=>{ await renderLeaderboard(); });

/* RESIZE recalc */
function recalcSizing(){ const cs = Math.floor(Math.min(CANVAS_W / COLS_USED, CANVAS_H / ROWS_USED)); offsetX = Math.floor((CANVAS_W - (cs*COLS_USED)) / 2); offsetY = Math.floor((CANVAS_H - (cs*ROWS_USED)) / 2); }
window.addEventListener('resize', ()=>{ recalcSizing(); draw(); });

/* INIT */
(function init(){
  setDifficulty(selectedDifficulty);
  bestScoreEl && (bestScoreEl.textContent = (function(){ const b = parseInt(localStorage.getItem(BEST_KEY) || '0',10); return isNaN(b)?0:b })());
  preparePreviewCanvas(nextCanvas); preparePreviewCanvas(holdCanvas);
  queue.push(...nextBag()); ensureQueue();
  allowGameOver=false; gameStarted=false; isRunning=false; isPaused=false; isGameOver=false;
  startOverlay.style.display='flex'; startOverlay.setAttribute('aria-hidden','false');
  overlay.style.display='none'; overlay.setAttribute('aria-hidden','true');
  pauseBtn.disabled=true; restartBtn.disabled=true;
  playerReset(); updateUI();
  musicVolume.value = musicVolumeVal;
  updateMusicUI();
  requestAnimationFrame(update);
})();

/* expose debug */
window.__tetris = { arena, player, queue, holdPiece, cfg:{CANVAS_W,CANVAS_H,COLS_USED,ROWS_USED,offsetX,offsetY,dropSpeedBase} };

/* small helper: createPiece defined earlier but ensure available */
function createPiece(type){ const s = SHAPES[type]; return s.map(r=>r.map(v=>v?type:0)); }
</script>
</body>
</html>
